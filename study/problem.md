# java 预热

* 发现在项目启动过程中出现大量的请求超时，进一步看服务的监控发现出现了CPU飚高、load飚高、RT飚高（甚至线程池满）等问题
* 解决办法：
  * 纯编译执行 : -Xcomp，导致启动变慢
  * 分层编译: -XX:+TieredCompilation c1=client启动编译器、c2=server启动编译器(会根据调用的次数统计，编译出来的代码执行效率比较高，启动时间长）
    * JIT 编译器在运行程序时有两种编译模式(C1/C2)可以选择，并且其会在运行时决定使用哪一种以达到最优性能。JDK7之后, JVM Server模式下将会开启分层编译（Tiered Compilation）策略, 由C1编译器和C2编译器相互协作共同来执行编译任务。分层编译策略将会根据编译器执行编译、优化的规模与耗时, 划分出不同的编译层次, 从而提高编译效率。 我们知道, 编译好的代码是会被载入codecache中, 在C1编译器中, 编译合格的类的数量将会高很多, 因为会导致codecache 经常是不够的, 而且目前机制来去计算出应用codecache设置多大合理。此外, 分层编译会导致编译后的代码被频繁写入或失效CodeCache, 存在导致codecache碎片化, 从而导致JIT编译效率暴跌风险。在实际应用中, 对于此问题不太严重的应用应该是可以解决一部分问题, 但对于比较严重的应用, ATA上的反馈效果并不明显。
  * JWarmup: 阿里预热功能
  * HSF分层发布 : 通过分批引流解决JIT引发的java c2 编译线程cpu占用率高的问题
  * 业务预热 : 通过提供预热脚本，在项目启动的时候进行预热
    * 缺点：
       * 业务在变动，需要设置不同的叫本
       * 难确定预热请求量
       * 难确定预热时间大小


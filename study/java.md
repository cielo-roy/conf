# Java 支持

## 内存屏障

* 内存屏障是硬件层面支持，是用来凭据不同cpu、以及单个cpu缓存信息在多线程处理过程中统一变量的值不同的问题.
* 可以分为Load Barrier 和Store Barrier（分别为读屏障和写屏障）
  * 对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；
  * 对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。
* 作用
  * 阻止屏障两侧的指令重排序
  * 强制把写换从去/告诉缓存中的脏数据协会主内存，让缓存中相应的数据失效

* Java中四种屏障，完成一系列的屏障和数据同步功能
  * LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
  * StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
  * LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
  * StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能

* volatile语义中的内存屏障，使用悲观心态处理，用来解决JVM层面的可见性问题
  * 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；
  * 在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；
* final语义中的内存屏障
  * 新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）
  * 初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）
  * 写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程/CPU可见，并阻止重排序。
  * 读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。
  * X86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。

## 多线程变成

### 避免死锁的几个常见方法：
 * 避免一个线程同时获取多个锁
 * 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
 * 尝试使用定时锁，使用lock.tryLock(timeout)替换使用内部锁机制
 * 对于数据库锁，加锁和解锁必须在一个数据库连接内处理，否则会出现解锁失败的情况
